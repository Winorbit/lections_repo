orbit_team = ["Egor", "Masha", "Ramin", "Luba", "Polina", "Alexander K.", "Alekasander M.", "Grisha"]
orbit_team_members = []

for user in orbit_team:
	if " " or "." in user:
		user.replace(" ", "_").replace(".", "")
		
	orbit_team_members.append({"username": user, 
								"email": f"{user}@winorbit.com", 
								"admin":False, 
								"speciality":None})
"""
Компьютер обрабатывает строчки кода как инструкции
Иногда инструкциибывают крайне подробными, как в примере выше. 
Но это не самый эффективный путь. Иногда нам нужна инструкция с вариативностью, которая ,при ее исполнеии, превраится в конкретную
Т.е "сходи в магазин за продуктами" это общя инструкция
А когда ты идешь в конкретный магазин за конкретными проодуктами это ее исполнение.
И исполнение этой инструкци отличается местом, временем суток и т.д.

Так и у нас, выше, есть конкретный, жестко заданный список из которго так же создается список словарей.
Это инструкция работает тлоько в данном файле и  только с данным списком, чо не оччень удобно.

Разумнее было бы создать инструкции, в которой описываеся ,что нужно принять любой список, и обработать его определнным образом.
А затем уже запрашивать исполнение этой инструкции в любом другом месте и любойм другом проекте.

Как это реализовать?
Основные инструменты нам уже знакомы - переменные, циклы и операторы.
Теперь нам нужно еще две вещи - локализовать данную инструкции, чтоб она была в эдаком пузыре
Чтоб данны,е такиЕ, как имена переменных, были доступны ТОЛЬКО в нашей инструкции. ЭТо нам помогают длать отступы, контролирующие область видимости

А так же, раз мы хотм вызывать эту инструкцию для выполнения, нам нужен какой-то маркер, идентификатор. "Сходить в магазин", например, тот самый идентификатор, за которым скрыта последовательность действий.
То есть, наше инструкции нужно имя.

Сейчас посмотрим ,какэ то работает. Для этого перепишем код сверху так, чтоб он был переносим и обрабтывал не только список orbit_team

Начем с того, что азобьем его на блоки и первым переишем кусочек, отвечающй за удаление из строки точек и пробелов.
"""

def replace_whitespaces(name):
	if " " or "." in name:
		name.replace(" ", "_").replace(".", "")


"""
def - ключеве слово, набор трех символов, которые сообщают интерпретатору Python, что мы хоти создать переносную инструкцию, или же ФУНКЦИЮ, как их называют в програмировании.
Оно нужно, чтоб интерпретатор понял как именно обрабатывать следующие символы.


replace_whitespaces  - ИМЯ ФУНКЦИИ нужное для того, чтоб мы могли ее ВЫЗЫВАТЬ. Собственно, стобы она делала то, что должна.
Мы назовем ее replace_whitespaces 
именования это вообще сложная штука, имя ведь длжно быть удобным, корекнтым с точки зрения синтаксиса языка и понятным другим програмистам.
Пока запомните пару простых правил - в именха функций не должно быть пробелов и тире, не латинских символов и спецсмволов.



(name) - круглые скобочки после имени функции принимают в себя аргумент(один, несколько или же ни одного). 
Аргумент - это кодовое имя того, что вы будуете обратывать в функции. Скажем, здесь мы знаем, что будем обрабывать строчку с именем
Но какое именно мы не знаем, в том и идея, чтобы оно могло быть любым.  Мы казываем внутри инструкции, что сделать с name и в момент вызыва вместо name удет любое другое значчение
Т.е это переменная которой присваивается каждый раз новое значение, зависящее от того, что ВЕСТОГО этого name вы подставите

Затем двоеточе, котрое в PYthon помогает отделять зоны видимости
таб, нужный для этого же и привычная уже замена символов.
"""

# Итак, инструкция готова:

def replace_whitespaces(name):
	if " " or "." in name:
		name.replace(" ", "_").replace(".", "")


# Теперь попробуем обратится к ней, т.е осуществить то ,что нзывается ВЫЗОВОМ ФУНКЦИИ
replace_whitespaces("E.go r")
"""
Для этого мы написали имя функции и, затем ,в круглыые скобчк передали НАСТОЯЩЕЕ знаяение ,строчку, у которой внутри кодовое имя name и которая будет обработана по инструкции.

Вообще мы до этого уже не раз ВЫЗЫВАЛИ ФУНКЦИИ
str(42)
int(str(42))

bool("egor")

Да, это все функции, интрукции, сья логказакопана в недах языка, но выполнены они так же ,как и наш replace_whitespaces
"""

# Результатом должна быть строчка. Имя без точек и проблов.
clear_name = replace_whitespaces("E.go r")
print(clear_name)

"""
Хммм...окей ,а почему тогда вместо имени мы получаем None?
Потому ,что функция это ОТДЕЛЬНАЯ ОБЛАСТЬ видимости
А все, что происходит в области видмости, не выходит за ее граница. И ,соответственно, имя изменилось, но ТОЛЬКО ВНУТРИ ФУНКЦИИ


Но мы ведь хоти получить его обратно!

Как попросить функции вернуть нам результат?
С помощь ключевого слова return
Оно говорит, чо полсевыполнения всех заданнхы внутри функции инструкций в конечном итоге пользовател получит то, что идет полсе слова return
"""



def replace_whitespaces(username):
	if " " or "." in username:
		fixed_name = username.replace(" ", "_").replace(".", "")
	return fixed_name

replaced = replace_whitespaces("")
print(replaced)

# Внутренняя логика и то, что отдает функция не обязатлеьно должныбыть связанны.
# Скажем, сделав так:

def replace_whitespaces(username):
	if " " or "." in username:
		fixed_name = username.replace(" ", "_").replace(".", "")
	return 58

replaced = replace_whitespaces("__A.nto n")
print(replaced)


# Мы, как вы сами моете видеть, попросим функцию выполнять замену символов ,но поьзователь в результате получит только чсло 58.
# Т.е да, вы можете не связывать логику и результат но, чаще всего это будет...несколько странно и бессмысленно.


# Логику, кстати, можно разместить и прямо сразу после return - это просто ключеве слово, отдающее ВСЕ что было после нго, т.е можно размещатьоперации любой сложности. 
# Но это сильно изуродует код.

def create_account_info(username):
	return {"username": username, 
				"email": f"{username}@winorbit.com", 
				"admin":False, 
				"speciality":None}

# Продложя решать нашу задачу, давайте сделаем функцию, которая бы могла и убирать пробелы и создавать з корректного юзернейма чловаь с инфрмацией о  пользователе!

# def create_account_info(username):
# 	if " " or "." in username:
# 		username = username.replace(" ", "_").replace(".", "_")

# 	user_info = {"username": username, 
# 				"email": f"{username}@winorbit.com", 
# 				"admin":False, 
# 				"speciality":None}

# 	return user_info


# Такой подоход имеет место быть, но ведь мы УЖЕ имеем функцию удаления проблелов!  Можем ли мы вызывать одну функцию внутри другой?
# Да легко! Больше того, этодаже нужно, ведь можно сильно облегчить себе работу.


def create_account_info(username):
	name = replace_whitespaces(username)

	user_info = {"username": name, 
				"email": f"{name}@winorbit.com", 
				"admin":False, 
				"speciality":None}

	return user_info

# Мы можем даже ОБЪЯВИТЬ т.е записать новую функцию внутри другой и там же ее вызывать!


def create_account_info(username):
	def replace_whitespaces(username):
		if " " or "." in username:
			fixed_name = username.replace(" ", "_").replace(".", "")
		return fixed_name

	name = replace_whitespaces(username)


	user_info = {"username": name, 
				"email": f"{name}@winorbit.com", 
				"admin":False, 
				"speciality":None}

	return user_info


# Но такой подод не очень продуктивен - он уродлив, дв и внутренняя функця доступна ТОЛЬКО внутри внешней.

# Итак, пора закончить переписывать нашу инструкцию для сздания списка профилей юзеров из списка имен:

def accounts_from_names(names):

	accounts = []

	for name in names:
		account = create_account_info(name)
		accounts.append(account)
	return accounts
	pass

orbit_team_members = accounts_from_names(defaut_pass)

print(orbit_team_members)



# Итоговый результат выглядит следующим образом:



def replace_whitespaces(username):
	if " " or "." in username:
		fixed_name = username.replace(" ", "_").replace(".", "")
	return fixed_name


def create_account_info(username):
	name = replace_whitespaces(username)

	user_info = {"username": name, 
				"email": f"{name}@winorbit.com", 
				"admin":False, 
				"speciality":None}

	return user_info

def accounts_from_names(names):

	accounts = []

	for name in names:
		account = create_account_info(name)
		accounts.append(account)
	return accounts
	pass

orbit_team_members = accounts_from_names(defaut_pass)

print(orbit_team_members)


# Если по колличеству строк мы немного превзошли первый вариант, то в гибкости кода и читаемости обошли его в разы.
# Кроме того каждая функция теперь отедлная сущность, которую можно спользовать как в связке с остальными, так и саму по себе 
# (более-менее, ведь кроме replace_whitespaces использкют вызыов коллег, но, все же)


# Есть несколько правил, которых стараются придерживаться программисты при написании функций. Они не являются обязатеными к выполнению, но сильно помогают в работе.

# - функции стоит выполнять одно конкетное дейсвие. Три маленьких однострочных функции, чаще сего, лучше, чем одна большая.
# - имя функции должно быть глаголом и обознаать то, что она делает.
# - имена функций стоит писать в одном стиле, в Python это либо CamelCase когда неско слов разделяются большими буквами либо использование ниних подчеркиваний
# accounts_from_names  /  AccountsFromNames

# Первый вариант распространен гоазд больше.  (во многом еще потомУ, что камелкейс применяется для именования  классов в Питоне, о чем мы поговорим позднее)

# Да, кроме того, функцию можно завершать ключевы словом pass
# Его можно исплоьзовать либо в декоратвных целях либо таК, ак на примере ниже ,чтоб инерпретатор не ломаля на функции без логики.

def function():
	pass


# Да,у вас мог осталься вопрос - мы иногда делил так:
# "Name".upper()
# {"ansver": 42}.keys()
# "Name".upper().replace(" ", "_").replace(".", "")

# Т.е через точку делали чт-ото, что подозритлеьно напоминает вызыов функций. И подсветка ,и скобочки и аргументы...
# Да ,это он и есть! 
# Дело в том, что мы писли с вами функции, которые могут применяться де и когда угодно.
# Но екоторыЕ, вроде .replace() принадлежат КОНКРЕТНОЙ СУЩНОСТИ, в нашем случае - строке. И эти функции явзялются часть этой самой строки.
# Такие функции зовутся МЕТОДАМИ.  И с ними мы разберемся на следующих занятиях.


# ДЗ - переписать прошлые дз с помощью функцй.

# функция крачайшего расстояния

# Функция ,создающая инф обо мне, сли аргумент - строка
# В птивнос лчуе пуст печатает сообщение "неправильный аргумент - его тип"

