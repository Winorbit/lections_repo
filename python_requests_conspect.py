"""
Нам нужен функционал, который будет ходить в интернет. Всегда можно написать его самому ,обратившись к глубинам языка, 
но гораздо проще, если имеешь дело с простой задачей, скачать уже существующее решение.
В нашем случае это библиотека requests, как раз предназначенная для того, чтобы гулять по интернету.

Скачаем ее командой 

pip install requests

pip - отдельная программа, с версии 3 идущая в комплекте с Питоном. Она предназначен для того, 
чтобы скачать со специального сайта библиотеки пайтон и устанавливать их.

Т.е, на самом деле, просто скачать в папку рядом с интерпретатором, но делать это так, 
чтобы эту библиотеку можно было добавлять к любым вашим программам командной

import 

как будто вся либа (набор python-файлов), лежит рядом с вашим проектом.

"""
import requests



requests.get("http://www.nbrb.by/API/ExRates/Rates/298")


# Мы ПОСЫЛАЕМ ЗАПРОС request, а в ответ мы получаем ОТВЕТ, response.
# Поэтому назовем нашу переменную res,

res = requests.get("http://www.nbrb.by/API/ExRates/Rates/298")

print(res)
"""
Хмм...окей, почему зайдя в браузере по этому адресу мы видим список словарей, а тут получаем некий Response <200>

Для того, чтобы это понять, пробежимся быстренько по запросам (подробно мы их еще рассмотрим на будущих занятиях)

Но коротко - мы шлем поток байтов от компьютера к компьютеру. На них установлены самые разные программы,  разные оси и железки, 
И как мы можем убедиться, что наш набор байтов будет нормально понят?

Пересылка данных это ведь не новая проблема, а довольно древняя.
По сути, это вопрос шифрования, ведь шифрование это процесс, при котором информация по какому-то алгоритму перебраться в другую.
И, зная алгоритм, мы можем восстановить оригинал. 

Например, шифр Цезаря это смещение каждой буквы в тексте на одну вперед.
В мире же программирования мы также уже сталкивались с вариантом шифрования.перекодирования - хэш-функции.

Мы берем данные, превращаем их в число и, зная верную хэш-функцию, можем вернуть обратно!

Соответственно, чтобы передавать данные между компьютерами, наша логика такова - передающая машина должна паковать инфу по какому-то алгоритму, 
а принимающая - знать алгоритм. И ,соответственно, уметь распаковывать

Подобные алгоритмы зовуться протоколами, это документы, прям настоящие, описывающее как именно должен работать тот тл ной механизм, 
а уже программы определенного типа пишутся, чтоб это реализовать в коде.

В нашем примере это выглядит так - есть самые разные протоколы передачи сообщений в сети, и один из них зовется HTTP.  
Это тот самый набор правил, по которому передаются некоторые интернет-запросы. Есть еще FTP ля файлов, UDP для стриминга и т.д, 
но, чаще всего, гуляя по веб-страницам, мы посылаем HTTP-запросы серверу, и получаем HTTP-ответы


И запрос и ответ имеют,по протоколу НТТР, свою структуру

Например, запрос должен иметь заголовки и тело 

А ответ - минимум две части - заголовки и статус.

Заголовки - служебная информация о сервере - дада, операционная система и т.д.

А СТАТУС это, собственно - статус ответа, а их может быть много. 
Удачный, неудачный, неудачный по вине сервера или же пользователя (неверный пароль, время ожидания и т.д.) и так далее.
Для каждый ситуации есть свой статус и они разбиты по группам.
К примеру 2XX - все хорошо
4ХХ - неверный запрос от пользователя. Например, известная страница 404.
404 это как раз статус.

И вот функция get библиотеки requests возвращает нам ОТВЕТ.
Состоящий, как мы помним,из
СТАТУСА
ЗАГОЛОВКОВ
ТЕЛА

"""

res = requests.get("http://www.nbrb.by/API/ExRates/Rates/298")
print(res.staus_code)
print(res.headers)
print(res.text)  #так мы получаем тело ответа в виде текста. Но нам же нужен JSON, трансфомирующийся в знакомый словарь? Для этого сделаем так
print(res.json())  #такая команда преврщает тело ответа, есл он является json-документом ,в питоновский словарь.


res = requests.get("http://www.nbrb.by/api/exrates/currencies")
print(type(res.json()))


"""
Окей, мы хотим получить курсы валют по отношению к беларускому рублю. Для этого нам необходимо знать банковский код валюты.
Эти коды позволяют нам ходить на страницу, содержащую инфомцию о курсе.
Но добыть эти коды мы можем только прочитав страницу, содержащую общую информацию обо всех валютах.
Поэтому зададим набор тех валют-аббревиатур, что нас интересую и почешем большой спсок словарей, вычленив только словари с интересующими нас ключами - аббревиатура валют.
"""

curr_abr = ("USD", "RUB", "EUR")

requested_curr_ids = []
currencies = res.json()
for curr in currencies:
	if curr["Cur_Abbreviation"] in curr_abr:
		print(curr["Cur_Code"])



requested_curr_ids = set([])
currencies = res.json()
for curr in currencies:
	if curr["Cur_Abbreviation"] in curr_abr:
		requested_curr_ids.add((curr["Cur_Code"]))

print(requested_curr_ids)


def get_ids_for_abrs(curr_abrs):
	requested_curr_ids = set([])
	res = requests.get("http://www.nbrb.by/api/exrates/currencies")

	currencies = res.json()
	for curr in currencies:
		if curr["Cur_Abbreviation"] in curr_abrs:
			requested_curr_ids.add((curr["Cur_Code"]))

	return requested_curr_ids
	pass

requested_ids = get_ids_for_abrs(("USD", "RUB", "EUR"))
print(requested_ids)



# Теперь, зная каждый код для каждой валюты, мы можем подставлять этот код в строку-аддрес ,ведующю к информации о курсе конкретной валюты.
curency_info = requests.get("http://www.nbrb.by/api/exrates/rates/643?parammode=1").json()

print(curency_info)
print(type(curency_info))

curr_data = {'Cur_ID': 298, 'Date': '2020-03-16T00:00:00', 'Cur_Abbreviation': 'RUB', 'Cur_Scale': 100, 'Cur_Name': 'Российских рублей', 'Cur_OfficialRate': 3.1958}

scale = curr_data["Cur_Scale"]
rate = curr_data["Cur_OfficialRate"]
name = curr_data["Cur_Name"]

print(f"Курс на сегодня: {rate} беларуских рублей за {scale} {name}")


def get_currencies_info():
	requested_ids = get_ids_for_abrs(("USD", "RUB", "EUR"))
	for x in requested_ids:
		curr_data = requests.get(f"http://www.nbrb.by/api/exrates/rates/{x}?parammode=1").json()

		scale = curr_data["Cur_Scale"]
		rate = curr_data["Cur_OfficialRate"]
		name = curr_data["Cur_Name"]

		print(f"Курс на сегодня: {rate} беларуских рублей за {scale} {name}")

get_currencies_info()

def get_currencies_info():
	message = "Курс на сегодня:"
	requested_ids = get_ids_for_abrs(("USD", "RUB", "EUR"))
	for x in requested_ids:
		curr_data = requests.get(f"http://www.nbrb.by/api/exrates/rates/{x}?parammode=1").json()

		scale = curr_data["Cur_Scale"]
		rate = curr_data["Cur_OfficialRate"]
		name = curr_data["Cur_Name"]

		message+=f"{rate} беларуских рублей за {scale} {name}\n"

	return message
	pass

curr_info = get_currencies_info()
print(curr_info)